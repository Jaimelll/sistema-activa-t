
"use server";

import { createClient } from "@/utils/supabase/server";

export async function getDashboardData() {
  const supabase = await createClient();

  // Fetch projects directly. Assuming a flat structure from CSV import or similar simple table.
  // User mentioned specific columns: "Año", "Nombre de la Institución:", "Región", "FONDOEMPLEO", "Contrapartidas", "TOTAL".
  // I will try to select these assuming they might be column names or mapped. 
  // However, usually DB columns are snake_case. 
  // ONE POSSIBILITY: The user uploaded a CSV and table has exact headers as names? Or normalized?
  // User said: "names of columns match EXACTLY with the CSV... Year (with tilde), Institution...".
  // I will try quoting them just in case Supabase preserved them, OR assume standard normalization.
  // BUT the current code queries 'proyectos' and 'metricas'. 
  // If the previous code was generated by me, it might be wrong. 
  // Let's TRY to fetch all columns first to debug what's actually there if I could.
  // Since I can't, I will follow the User's "Exact Mapping" instruction literally but apply it to the query.
  // Use double quotes for special characters if needed.

  const { data, error } = await supabase
    .from('proyectos')
    .select('*');
  // Intentionally selecting * to see what we get in logs if mapping fails, 
  // but for the return we will map.

  if (error) {
    console.error("Error fetching dashboard data:", error);
    return [];
  }

  console.log("Raw Supabase Data Sample (first item):", data?.[0]);

  if (!data || data.length === 0) {
    console.warn("Posible bloqueo por RLS: No data returned from Supabase via standard client or empty table.");
    return [];
  }

  // Mapping based on confirmed CSV columns:
  // 'Año', 'Región', 'Nombre de la Institución:', 'FONDOEMPLEO', 'Contrapartidas', 'TOTAL'

  return data.map((p: any) => {
    // Safe access helper
    const getVal = (keys: string[]) => {
      for (const k of keys) {
        if (p[k] !== undefined) return p[k];
        // Check quoted or lowercase variants
        if (p[k.toLowerCase()] !== undefined) return p[k.toLowerCase()];
      }
      return 0;
    };

    const getName = (keys: string[]) => {
      for (const k of keys) {
        if (p[k] !== undefined) return p[k];
        if (p[k.toLowerCase()] !== undefined) return p[k.toLowerCase()];
      }
      return 'Sin Nombre';
    }

    const getString = (keys: string[], defaultVal = '') => {
      for (const k of keys) {
        if (p[k] !== undefined) return p[k];
        if (p[k.toLowerCase()] !== undefined) return p[k.toLowerCase()];
      }
      return defaultVal;
    }

    // Specific mapping
    // Note: Supabase/Postgres columns are usually lowercase, but we check exact first just in case.
    const year = getString(['Año', 'año', 'brano', 'year'], new Date(p.created_at || Date.now()).getFullYear().toString());
    const region = getString(['Región', 'región', 'region'], 'Desconocido');
    const estado = getString(['Estado', 'estado'], 'Sin Estado');
    const nombre = getName(['Nombre de la Institución:', 'nombre de la institución:', 'nombre', 'Nombre de la Institución']);

    // Numeric fields - prioritize confirmed column names
    const fondoempleo = Number(getVal(['FONDOEMPLEO', 'fondoempleo', 'monto_fondoempleo'])) || 0;
    const contrapartida = Number(getVal(['Contrapartidas', 'contrapartidas', 'monto_contrapartida'])) || 0;
    const total = Number(getVal(['TOTAL', 'total', 'monto_total'])) || 0;
    // 'Beneficiarios' wasn't explicitly confirmed in the list but implied in previous code, keeping soft check
    const beneficiarios = Number(getVal(['Beneficiarios', 'beneficiarios'])) || 0;

    return {
      id: p.id || Math.random(), // fallback id if none
      nombre: nombre,
      region: region,
      estado: estado,
      year: String(year),
      monto_fondoempleo: fondoempleo,
      monto_contrapartida: contrapartida,
      monto_total: total,
      beneficiarios: beneficiarios
    };
  });
}
